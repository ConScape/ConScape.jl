var documenterSearchIndex = {"docs":
[{"location":"#ConScape.jl","page":"ConScape.jl","title":"ConScape.jl","text":"","category":"section"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"A Julia package for landscape connectivity.","category":"page"},{"location":"#Example","page":"ConScape.jl","title":"Example","text":"","category":"section"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"In the following, a small example of the functionality is given. First, we canstruct an artificial landscape with a wall and two corridors. The landscape is stored in a Grid struct.","category":"page"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"using ConScape\ng = ConScape.perm_wall_sim(30, 60, corridorwidths=(3,2), costs=ConScape.MinusLog()) # Generate an artificial landscape\nConScape.plot_outdegrees(g)","category":"page"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"From a Grid, we can now create a GridRSP which we can use to compute the randomized shortest path based quality weighted betweenness with the temperature parameter θ=0.2.","category":"page"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"h = ConScape.GridRSP(g, θ=0.2)\nbet_q = ConScape.betweenness_qweighted(h)\nConScape.heatmap(bet_q, yflip=true)","category":"page"},{"location":"#Details","page":"ConScape.jl","title":"Details","text":"","category":"section"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"The section provides more details about the functions of this package including exact call signatures.","category":"page"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"DocTestSetup = quote\n    using ConScape\nend","category":"page"},{"location":"#Grid","page":"ConScape.jl","title":"Grid","text":"","category":"section"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"ConScape.Grid\nConScape.free_energy_distance\nConScape.is_strongly_connected\nConScape.largest_subgraph\nConScape.least_cost_distance\nConScape.sum_neighborhood\nConScape.coarse_graining","category":"page"},{"location":"#ConScape.Grid","page":"ConScape.jl","title":"ConScape.Grid","text":"Grid(nrows::Integer,\n          ncols::Integer;\n          affinities=nothing,\n          qualities::Matrix=ones(nrows, ncols),\n          source_qualities::Matrix=qualities,\n          target_qualities::AbstractMatrix=qualities,\n          costs::Union{Transformation,SparseMatrixCSC{Float64,Int}}=MinusLog(),\n          prune=true)::Grid\n\nConstruct a Grid from an affinities matrix of type SparseMatrixCSC. It is possible to also supply matrices of source_qualities and target_qualities as well as a costs function that maps the affinities matrix to a costs matrix. Alternatively, it is possible to supply a matrix to costs directly. If prune=true (the default), the affinity and cost matrices will be pruned to exclude unreachable nodes.\n\n\n\n\n\n","category":"type"},{"location":"#ConScape.free_energy_distance","page":"ConScape.jl","title":"ConScape.free_energy_distance","text":"free_energy_distance(\n    g::Grid;\n    target::Union{Tuple{Int,Int},Nothing}=nothing,\n    θ::Union{Real,Nothing}=nothing,\n    approx::Bool=false\n)\n\nCompute the directed free energy distance from all source nodes to all target nodes in the graph defined by g using the inverse temperature parameter θ. The computation can either continue until convergence when setting approx=false (the default) or return an approximate result based on just a single iteration of the Bellman-Ford algorithm when approx=true.\n\n\n\n\n\n","category":"type"},{"location":"#LightGraphs.is_strongly_connected","page":"ConScape.jl","title":"LightGraphs.is_strongly_connected","text":"is_strongly_connected(g::Grid)::Bool\n\nTest if graph defined by Grid is fully connected.\n\nExamples\n\njulia> affinities = [1/4 0 1/4 1/4\n                     1/4 0 1/4 1/4\n                     1/4 0 1/4 1/4\n                     1/4 0 1/4 1/4];\n\njulia> grid = ConScape.Grid(size(affinities)..., affinities=ConScape.graph_matrix_from_raster(affinities), prune=false)\nConScape.Grid of size 4x4\n\njulia> ConScape.is_strongly_connected(grid)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.largest_subgraph","page":"ConScape.jl","title":"ConScape.largest_subgraph","text":"largest_subgraph(g::Grid)::Grid\n\nExtract the largest fully connected subgraph of the Grid. The returned Grid will have the same size as the input Grid but only nodes associated with the largest subgraph of the affinities will be active.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.least_cost_distance","page":"ConScape.jl","title":"ConScape.least_cost_distance","text":"least_cost_distance(g::Grid)::Matrix{Float64}\n\nCompute the least cost distance from all the cells in the grid to all target cells.\n\nExamples\n\njulia> affinities = [1/4 0 1/2 1/4\n                     1/4 0 1/2 1/4\n                     1/4 0 1/2 1/4\n                     1/4 0 1/2 1/4];\n\njulia> grid = ConScape.Grid(size(affinities)..., affinities=ConScape.graph_matrix_from_raster(affinities))\n[ Info: cost graph contains 6 strongly connected subgraphs\n[ Info: removing 8 nodes from affinity and cost graphs\nConScape.Grid of size 4x4\n\njulia> ConScape.least_cost_distance(grid)\n8×8 Matrix{Float64}:\n 0.0       0.693147  1.38629   2.07944   0.693147  1.03972   1.73287   2.42602\n 0.693147  0.0       0.693147  1.38629   1.03972   0.693147  1.03972   1.73287\n 1.38629   0.693147  0.0       0.693147  1.73287   1.03972   0.693147  1.03972\n 2.07944   1.38629   0.693147  0.0       2.42602   1.73287   1.03972   0.693147\n 1.38629   1.73287   2.42602   3.11916   0.0       1.38629   2.77259   3.46574\n 1.73287   1.38629   1.73287   2.42602   1.38629   0.0       1.38629   2.77259\n 2.42602   1.73287   1.38629   1.73287   2.77259   1.38629   0.0       1.38629\n 3.11916   2.42602   1.73287   1.38629   3.46574   2.77259   1.38629   0.0\n\n\n\n\n\n","category":"type"},{"location":"#ConScape.sum_neighborhood","page":"ConScape.jl","title":"ConScape.sum_neighborhood","text":"sum_neighborhood(g::Grid, rc::Tuple{Int,Int}, npix::Integer)::Float64\n\nA helper-function, used by coarse_graining, that computes the sum of pixels within a npix neighborhood around the target rc.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.coarse_graining","page":"ConScape.jl","title":"ConScape.coarse_graining","text":"coarse_graining(g::Grid, npix::Integer)::Array\n\nCreates a sparse matrix of target qualities for the landmarks based on merging npix pixels into the center pixel.\n\n\n\n\n\n","category":"function"},{"location":"#GridRSP-(Randomized-Shortest-Path)","page":"ConScape.jl","title":"GridRSP (Randomized Shortest Path)","text":"","category":"section"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"ConScape.GridRSP\nConScape.expected_cost\nConScape.betweenness_qweighted\nConScape.betweenness_kweighted\nConScape.edge_betweenness_qweighted\nConScape.edge_betweenness_kweighted\nConScape.mean_kl_divergence\nConScape.mean_lc_kl_divergence\nConScape.least_cost_kl_divergence\nConScape.connected_habitat\nConScape.eigmax\nConScape.criticality","category":"page"},{"location":"#ConScape.GridRSP","page":"ConScape.jl","title":"ConScape.GridRSP","text":"GridRSP(g::Grid; θ=nothing)::GridRSP\n\nConstruct a GridRSP from a g::Grid based on the inverse temperature parameter θ::Real.\n\n\n\n\n\n","category":"type"},{"location":"#ConScape.expected_cost","page":"ConScape.jl","title":"ConScape.expected_cost","text":"free_energy_distance(\n    g::Grid;\n    θ::Union{Real,Nothing}=nothing,\n    approx::Bool=false\n)\n\nCompute the randomized shorted path based expected costs from all source nodes to all target nodes in the graph defined by g using the inverse temperature parameter θ. The computation can either continue until convergence when setting approx=false (the default) or return an approximate result based on just a single iteration of the Bellman-Ford algorithm when approx=true.\n\n\n\n\n\nexpected_cost(grsp::GridRSP)::Matrix{Float64}\n\nCompute RSP expected costs from all nodes.\n\n\n\n\n\n","category":"type"},{"location":"#ConScape.betweenness_qweighted","page":"ConScape.jl","title":"ConScape.betweenness_qweighted","text":"betweenness_qweighted(grsp::GridRSP)::Matrix{Float64}\n\nCompute RSP betweenness of all nodes weighted by source and target qualities.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.betweenness_kweighted","page":"ConScape.jl","title":"ConScape.betweenness_kweighted","text":"betweenness_kweighted(grsp::GridRSP;\n    connectivity_function=expected_cost,\n    distance_transformation=inv(grsp.g.costfunction),\n    diagvalue=nothing])::SparseMatrixCSC{Float64,Int}\n\nCompute RSP betweenness of all nodes weighted with proximities computed with respect to the distance/proximity measure defined by connectivity_function. Optionally, an inverse cost function can be passed. The function will be applied elementwise to the matrix of distances to convert it to a matrix of proximities. If no inverse cost function is passed the the inverse of the cost function is used for the conversion of distances.\n\nThe optional diagvalue element specifies which value to use for the diagonal of the matrix of proximities, i.e. after applying the inverse cost function to the matrix of distances. When nothing is specified, the diagonal elements won't be adjusted.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.edge_betweenness_qweighted","page":"ConScape.jl","title":"ConScape.edge_betweenness_qweighted","text":"edge_betweenness_qweighted(grsp::GridRSP)::Matrix{Float64}\n\nCompute RSP betweenness of all edges weighted by source and target qualities. Returns a sparse matrix where element (i,j) is the betweenness of edge (i,j).\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.edge_betweenness_kweighted","page":"ConScape.jl","title":"ConScape.edge_betweenness_kweighted","text":"edge_betweenness_kweighted(grsp::GridRSP; [distance_transformation=inv(grsp.g.costfunction), diagvalue=nothing])::SparseMatrixCSC{Float64,Int}\n\nCompute RSP betweenness of all edges weighted by qualities of source s and target t and the proximity between s and t. Returns a\nsparse matrix where element (i,j) is the betweenness of edge (i,j).\n\nThe optional `diagvalue` element specifies which value to use for the diagonal of the matrix\nof proximities, i.e. after applying the inverse cost function to the matrix of expected costs.\nWhen nothing is specified, the diagonal elements won't be adjusted.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.mean_kl_divergence","page":"ConScape.jl","title":"ConScape.mean_kl_divergence","text":"mean_kl_divergence(grsp::GridRSP)::Float64\n\nCompute the mean Kullback–Leibler divergence between the free energy distances and the RSP expected costs for grsp::GridRSP.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.mean_lc_kl_divergence","page":"ConScape.jl","title":"ConScape.mean_lc_kl_divergence","text":"mean_lc_kl_divergence(grsp::GridRSP)::Float64\n\nCompute the mean Kullback–Leibler divergence between the least-cost path and the random path distribution for grsp::GridRSP, weighted by the qualities of the source and target node.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.least_cost_kl_divergence","page":"ConScape.jl","title":"ConScape.least_cost_kl_divergence","text":"least_cost_kl_divergence(grsp::GridRSP, target::Tuple{Int,Int})\n\nCompute the least cost Kullback-Leibler divergence from each cell in the g in h to the target cell.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.connected_habitat","page":"ConScape.jl","title":"ConScape.connected_habitat","text":"connected_habitat(grsp::Union{Grid,GridRSP};\n    connectivity_function=expected_cost,\n    distance_transformation=nothing,\n    diagvalue=nothing,\n    θ::Union{Nothing,Real}=nothing)::Matrix{Float64}\n\nCompute RSP connected_habitat of all nodes. An inverse cost function must be passed for a Grid argument but is optional for GridRSP. The function will be applied elementwise to the matrix of distances to convert it to a matrix of proximities. If no inverse cost function is passed the the inverse of the cost function is used for the conversion of the proximities.\n\nThe optional diagvalue element specifies which value to use for the diagonal of the matrix of proximities, i.e. after applying the inverse cost function to the matrix of distances. When nothing is specified, the diagonal elements won't be adjusted.\n\nconnectivity_function determines which function is used for computing the matrix of proximities. If connectivity_function is a DistanceFunction, then it is used for computing distances, which is converted to proximities using distance_transformation. If connectivity_function is a ProximityFunction, then proximities are computed directly using it. The default is expected_cost.\n\nFor Grid object, the inverse temperature parameter θ must be passed when the connectivity_function requires it such as expected_cost.\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.eigmax","page":"ConScape.jl","title":"LinearAlgebra.eigmax","text":"eigmax(grsp::GridRSP;\n    connectivity_function=expected_cost,\n    distance_transformation=nothing,\n    diagvalue=nothing,\n    tol=1e-14)\n\nCompute the largest eigenvalue triple (left vector, value, and right vector) of the quality scaled proximities with respect to the distance/proximity measure defined by connectivity_function. If connectivity_function is a distance measure then the distances are transformed to proximities by distance_transformation which defaults to the inverse of the costfunction in the underlying Grid (if defined). Optionally, the diagonal values of the proximity matrix may be set to diagvalue. The tol argument specifies the convergence tolerance in the Arnoldi based eigensolver.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.criticality","page":"ConScape.jl","title":"ConScape.criticality","text":"criticality(grsp::GridRSP[;\n            distance_transformation=inv(grsp.g.costfunction),\n            diagvalue=nothing,\n            avalue=floatmin(),\n            qˢvalue=0.0,\n            qᵗvalue=0.0])\n\nCompute the landscape criticality for each target cell by setting setting affinities for the cell to avalue as well as the source and target qualities associated with the cell to qˢvalue and qᵗvalue respectively. It is required that avalue is positive to avoid that the graph becomes disconnected.\n\n\n\n\n\n","category":"function"},{"location":"#Utility-functions","page":"ConScape.jl","title":"Utility functions","text":"","category":"section"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"ConScape.graph_matrix_from_raster\nConScape.mapnz\nConScape.readasc\nConScape.writeasc","category":"page"},{"location":"#ConScape.graph_matrix_from_raster","page":"ConScape.jl","title":"ConScape.graph_matrix_from_raster","text":"graph_matrix_from_raster(R::Matrix[, type=AffinityMatrix, neighbors::Tuple=N8, weight=TargetWeight])::SparseMatrixCSC\n\nCompute a graph matrix, i.e. an affinity or cost matrix of the raster image R of cell affinities or cell costs. The values are computed as either the value of the target cell (TargetWeight) or as harmonic (arithmetic) means of the cell affinities (costs) weighted by the grid distance (AverageWeight). The values can be computed with respect to eight neighbors (N8) or four neighbors (N4).\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.mapnz","page":"ConScape.jl","title":"ConScape.mapnz","text":"mapnz(f, A::SparseMatrixCSC)::SparseMatrixCSC\n\nMap the non-zero values of a sparse matrix A with the function f.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.readasc","page":"ConScape.jl","title":"ConScape.readasc","text":"readasc(::Union{String,IO}; nodata_value=0.0)::Tuple{Matrix{Float64}, Dict{String,Int}}\n\nRead asc file of raster data and return tuple of a raster matrix and a dictionary containing the metadata information.\n\n\n\n\n\n","category":"function"},{"location":"#ConScape.writeasc","page":"ConScape.jl","title":"ConScape.writeasc","text":"writeasc(fn::String, m::Matrix{<:Real}; kwargs...)\n\nWrite the raster matrix m to a file named fn. It's possible to pass metadata arguments xllcorner, yllcorner, cellsize, nodata_value as keywords or as a single dictionary.\n\n\n\n\n\n","category":"function"},{"location":"","page":"ConScape.jl","title":"ConScape.jl","text":"This package is derived from the Python package reindeers.","category":"page"}]
}
