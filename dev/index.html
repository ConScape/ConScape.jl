<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ConScape.jl · ConScape</title><meta name="title" content="ConScape.jl · ConScape"/><meta property="og:title" content="ConScape.jl · ConScape"/><meta property="twitter:title" content="ConScape.jl · ConScape"/><meta name="description" content="Documentation for ConScape."/><meta property="og:description" content="Documentation for ConScape."/><meta property="twitter:description" content="Documentation for ConScape."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ConScape</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ConScape.jl</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Details"><span>Details</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ConScape.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ConScape.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ConScape/ConScape.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ConScape/ConScape.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ConScape.jl"><a class="docs-heading-anchor" href="#ConScape.jl">ConScape.jl</a><a id="ConScape.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ConScape.jl" title="Permalink"></a></h1><p>A Julia package for landscape connectivity.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>In the following, a small example of the functionality is given. First, we canstruct an artificial landscape with a wall and two corridors. The landscape is stored in a <code>Grid</code> struct.</p><pre><code class="language-julia hljs">using ConScape
g = ConScape.perm_wall_sim(30, 60, corridorwidths=(3,2), costs=ConScape.MinusLog()) # Generate an artificial landscape
ConScape.plot_outdegrees(g)</code></pre><img src="index-6e7634bb.svg" alt="Example block output"/><p>From a <code>Grid</code>, we can now create a <code>GridRSP</code> which we can use to compute the randomized shortest path based quality weighted betweenness with the temperature parameter <code>θ=0.2</code>.</p><pre><code class="language-julia hljs">h = ConScape.GridRSP(g, θ=0.2)
bet_q = ConScape.betweenness_qweighted(h)
ConScape.heatmap(bet_q, yflip=true)</code></pre><img src="index-156a3e95.svg" alt="Example block output"/><h2 id="Details"><a class="docs-heading-anchor" href="#Details">Details</a><a id="Details-1"></a><a class="docs-heading-anchor-permalink" href="#Details" title="Permalink"></a></h2><p>The section provides more details about the functions of this package including exact call signatures.</p><h3 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.Grid" href="#ConScape.Grid"><code>ConScape.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Grid(nrows::Integer,
          ncols::Integer;
          affinities=nothing,
          qualities::Matrix=ones(nrows, ncols),
          source_qualities::Matrix=qualities,
          target_qualities::AbstractMatrix=qualities,
          costs::Union{Transformation,SparseMatrixCSC{Float64,Int}}=MinusLog(),
          prune=true)::Grid</code></pre><p>Construct a <code>Grid</code> from an <code>affinities</code> matrix of type <code>SparseMatrixCSC</code>. It is possible to also supply matrices of <code>source_qualities</code> and <code>target_qualities</code> as well as a <code>costs</code> function that maps the <code>affinities</code> matrix to a <code>costs</code> matrix. Alternatively, it is possible to supply a matrix to <code>costs</code> directly. If <code>prune=true</code> (the default), the affinity and cost matrices will be pruned to exclude unreachable nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L31-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.free_energy_distance" href="#ConScape.free_energy_distance"><code>ConScape.free_energy_distance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">free_energy_distance(
    g::Grid;
    target::Union{Tuple{Int,Int},Nothing}=nothing,
    θ::Union{Real,Nothing}=nothing,
    approx::Bool=false
)</code></pre><p>Compute the directed free energy distance from all source nodes to all target nodes in the graph defined by <code>g</code> using the inverse temperature parameter <code>θ</code>. The computation can either continue until convergence when setting <code>approx=false</code> (the default) or return an approximate result based on just a single iteration of the Bellman-Ford algorithm when <code>approx=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L387-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightGraphs.is_strongly_connected" href="#LightGraphs.is_strongly_connected"><code>LightGraphs.is_strongly_connected</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_strongly_connected(g::Grid)::Bool</code></pre><p>Test if graph defined by Grid is fully connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; affinities = [1/4 0 1/4 1/4
                     1/4 0 1/4 1/4
                     1/4 0 1/4 1/4
                     1/4 0 1/4 1/4];

julia&gt; grid = ConScape.Grid(size(affinities)..., affinities=ConScape.graph_matrix_from_raster(affinities), prune=false)
ConScape.Grid of size 4x4

julia&gt; ConScape.is_strongly_connected(grid)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L179-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.largest_subgraph" href="#ConScape.largest_subgraph"><code>ConScape.largest_subgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">largest_subgraph(g::Grid)::Grid</code></pre><p>Extract the largest fully connected subgraph of the <code>Grid</code>. The returned <code>Grid</code> will have the same size as the input <code>Grid</code> but only nodes associated with the largest subgraph of the affinities will be active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.least_cost_distance" href="#ConScape.least_cost_distance"><code>ConScape.least_cost_distance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">least_cost_distance(g::Grid)::Matrix{Float64}</code></pre><p>Compute the least cost distance from all the cells in the grid to all target cells.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; affinities = [1/4 0 1/2 1/4
                     1/4 0 1/2 1/4
                     1/4 0 1/2 1/4
                     1/4 0 1/2 1/4];

julia&gt; grid = ConScape.Grid(size(affinities)..., affinities=ConScape.graph_matrix_from_raster(affinities))
[ Info: cost graph contains 6 strongly connected subgraphs
[ Info: removing 8 nodes from affinity and cost graphs
ConScape.Grid of size 4x4

julia&gt; ConScape.least_cost_distance(grid)
8×8 Matrix{Float64}:
 0.0       0.693147  1.38629   2.07944   0.693147  1.03972   1.73287   2.42602
 0.693147  0.0       0.693147  1.38629   1.03972   0.693147  1.03972   1.73287
 1.38629   0.693147  0.0       0.693147  1.73287   1.03972   0.693147  1.03972
 2.07944   1.38629   0.693147  0.0       2.42602   1.73287   1.03972   0.693147
 1.38629   1.73287   2.42602   3.11916   0.0       1.38629   2.77259   3.46574
 1.73287   1.38629   1.73287   2.42602   1.38629   0.0       1.38629   2.77259
 2.42602   1.73287   1.38629   1.73287   2.77259   1.38629   0.0       1.38629
 3.11916   2.42602   1.73287   1.38629   3.46574   2.77259   1.38629   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L243-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.sum_neighborhood" href="#ConScape.sum_neighborhood"><code>ConScape.sum_neighborhood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sum_neighborhood(g::Grid, rc::Tuple{Int,Int}, npix::Integer)::Float64</code></pre><p>A helper-function, used by coarse_graining, that computes the sum of pixels within a npix neighborhood around the target rc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.coarse_graining" href="#ConScape.coarse_graining"><code>ConScape.coarse_graining</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coarse_graining(g::Grid, npix::Integer)::Array</code></pre><p>Creates a sparse matrix of target qualities for the landmarks based on merging npix pixels into the center pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L314-L318">source</a></section></article><h3 id="GridRSP-(Randomized-Shortest-Path)"><a class="docs-heading-anchor" href="#GridRSP-(Randomized-Shortest-Path)">GridRSP (Randomized Shortest Path)</a><a id="GridRSP-(Randomized-Shortest-Path)-1"></a><a class="docs-heading-anchor-permalink" href="#GridRSP-(Randomized-Shortest-Path)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.GridRSP" href="#ConScape.GridRSP"><code>ConScape.GridRSP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridRSP(g::Grid; θ=nothing)::GridRSP</code></pre><p>Construct a GridRSP from a <code>g::Grid</code> based on the inverse temperature parameter <code>θ::Real</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.expected_cost" href="#ConScape.expected_cost"><code>ConScape.expected_cost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">free_energy_distance(
    g::Grid;
    θ::Union{Real,Nothing}=nothing,
    approx::Bool=false
)</code></pre><p>Compute the randomized shorted path based expected costs from all source nodes to all target nodes in the graph defined by <code>g</code> using the inverse temperature parameter <code>θ</code>. The computation can either continue until convergence when setting <code>approx=false</code> (the default) or return an approximate result based on just a single iteration of the Bellman-Ford algorithm when <code>approx=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/grid.jl#L343-L355">source</a></section><section><div><pre><code class="language-julia hljs">expected_cost(grsp::GridRSP)::Matrix{Float64}</code></pre><p>Compute RSP expected costs from all nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.betweenness_qweighted" href="#ConScape.betweenness_qweighted"><code>ConScape.betweenness_qweighted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">betweenness_qweighted(grsp::GridRSP)::Matrix{Float64}</code></pre><p>Compute RSP betweenness of all nodes weighted by source and target qualities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.betweenness_kweighted" href="#ConScape.betweenness_kweighted"><code>ConScape.betweenness_kweighted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">betweenness_kweighted(grsp::GridRSP;
    connectivity_function=expected_cost,
    distance_transformation=inv(grsp.g.costfunction),
    diagvalue=nothing])::SparseMatrixCSC{Float64,Int}</code></pre><p>Compute RSP betweenness of all nodes weighted with proximities computed with respect to the distance/proximity measure defined by <code>connectivity_function</code>. Optionally, an inverse cost function can be passed. The function will be applied elementwise to the matrix of distances to convert it to a matrix of proximities. If no inverse cost function is passed the the inverse of the cost function is used for the conversion of distances.</p><p>The optional <code>diagvalue</code> element specifies which value to use for the diagonal of the matrix of proximities, i.e. after applying the inverse cost function to the matrix of distances. When nothing is specified, the diagonal elements won&#39;t be adjusted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.edge_betweenness_qweighted" href="#ConScape.edge_betweenness_qweighted"><code>ConScape.edge_betweenness_qweighted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_betweenness_qweighted(grsp::GridRSP)::Matrix{Float64}</code></pre><p>Compute RSP betweenness of all edges weighted by source and target qualities. Returns a sparse matrix where element (i,j) is the betweenness of edge (i,j).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.edge_betweenness_kweighted" href="#ConScape.edge_betweenness_kweighted"><code>ConScape.edge_betweenness_kweighted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_betweenness_kweighted(grsp::GridRSP; [distance_transformation=inv(grsp.g.costfunction), diagvalue=nothing])::SparseMatrixCSC{Float64,Int}

Compute RSP betweenness of all edges weighted by qualities of source s and target t and the proximity between s and t. Returns a
sparse matrix where element (i,j) is the betweenness of edge (i,j).

The optional `diagvalue` element specifies which value to use for the diagonal of the matrix
of proximities, i.e. after applying the inverse cost function to the matrix of expected costs.
When nothing is specified, the diagonal elements won&#39;t be adjusted.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L147-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.mean_kl_divergence" href="#ConScape.mean_kl_divergence"><code>ConScape.mean_kl_divergence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mean_kl_divergence(grsp::GridRSP)::Float64</code></pre><p>Compute the mean Kullback–Leibler divergence between the free energy distances and the RSP expected costs for <code>grsp::GridRSP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.mean_lc_kl_divergence" href="#ConScape.mean_lc_kl_divergence"><code>ConScape.mean_lc_kl_divergence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mean_lc_kl_divergence(grsp::GridRSP)::Float64</code></pre><p>Compute the mean Kullback–Leibler divergence between the least-cost path and the random path distribution for <code>grsp::GridRSP</code>, weighted by the qualities of the source and target node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.least_cost_kl_divergence" href="#ConScape.least_cost_kl_divergence"><code>ConScape.least_cost_kl_divergence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">least_cost_kl_divergence(grsp::GridRSP, target::Tuple{Int,Int})</code></pre><p>Compute the least cost Kullback-Leibler divergence from each cell in the g in <code>h</code> to the <code>target</code> cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L279-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.connected_habitat" href="#ConScape.connected_habitat"><code>ConScape.connected_habitat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">connected_habitat(grsp::Union{Grid,GridRSP};
    connectivity_function=expected_cost,
    distance_transformation=nothing,
    diagvalue=nothing,
    θ::Union{Nothing,Real}=nothing,
    approx::Bool=false)::Matrix{Float64}</code></pre><p>Compute RSP connected_habitat of all nodes. An inverse cost function must be passed for a <code>Grid</code> argument but is optional for <code>GridRSP</code>. The function will be applied elementwise to the matrix of distances to convert it to a matrix of proximities. If no inverse cost function is passed the the inverse of the cost function is used for the conversion of the proximities.</p><p>The optional <code>diagvalue</code> element specifies which value to use for the diagonal of the matrix of proximities, i.e. after applying the inverse cost function to the matrix of distances. When nothing is specified, the diagonal elements won&#39;t be adjusted.</p><p><code>connectivity_function</code> determines which function is used for computing the matrix of proximities. If <code>connectivity_function</code> is a <code>DistanceFunction</code>, then it is used for computing distances, which is converted to proximities using <code>distance_transformation</code>. If <code>connectivity_function</code> is a <code>ProximityFunction</code>, then proximities are computed directly using it. The default is <code>expected_cost</code>.</p><p>For <code>Grid</code> objects, the inverse temperature parameter <code>θ</code> must be passed when the <code>connectivity_function</code> requires it such as <code>expected_cost</code>. Also for <code>Grid</code> objects, the <code>approx</code> Boolean argument can be set to <code>true</code> to switch to a cheaper approximate solution of the <code>connectivity_function</code>. The default value is <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L297-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigmax" href="#LinearAlgebra.eigmax"><code>LinearAlgebra.eigmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigmax(grsp::GridRSP;
    connectivity_function=expected_cost,
    distance_transformation=nothing,
    diagvalue=nothing,
    tol=1e-14)</code></pre><p>Compute the largest eigenvalue triple (left vector, value, and right vector) of the quality scaled proximities with respect to the distance/proximity measure defined by <code>connectivity_function</code>. If <code>connectivity_function</code> is a distance measure then the distances are transformed to proximities by <code>distance_transformation</code> which defaults to the inverse of the <code>costfunction</code> in the underlying <code>Grid</code> (if defined). Optionally, the diagonal values of the proximity matrix may be set to <code>diagvalue</code>. The <code>tol</code> argument specifies the convergence tolerance in the Arnoldi based eigensolver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L433-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.criticality" href="#ConScape.criticality"><code>ConScape.criticality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">criticality(grsp::GridRSP[;
            distance_transformation=inv(grsp.g.costfunction),
            diagvalue=nothing,
            avalue=floatmin(),
            qˢvalue=0.0,
            qᵗvalue=0.0])</code></pre><p>Compute the landscape criticality for each target cell by setting setting affinities for the cell to <code>avalue</code> as well as the source and target qualities associated with the cell to <code>qˢvalue</code> and <code>qᵗvalue</code> respectively. It is required that <code>avalue</code> is positive to avoid that the graph becomes disconnected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/gridrsp.jl#L558-L570">source</a></section></article><h3 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.graph_matrix_from_raster" href="#ConScape.graph_matrix_from_raster"><code>ConScape.graph_matrix_from_raster</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">graph_matrix_from_raster(R::Matrix[, type=AffinityMatrix, neighbors::Tuple=N8, weight=TargetWeight])::SparseMatrixCSC</code></pre><p>Compute a graph matrix, i.e. an affinity or cost matrix of the raster image <code>R</code> of cell affinities or cell costs. The values are computed as either the value of the target cell (TargetWeight) or as harmonic (arithmetic) means of the cell affinities (costs) weighted by the grid distance (AverageWeight). The values can be computed with respect to eight neighbors (<code>N8</code>) or four neighbors (<code>N4</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/utils.jl#L88-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.mapnz" href="#ConScape.mapnz"><code>ConScape.mapnz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapnz(f, A::SparseMatrixCSC)::SparseMatrixCSC</code></pre><p>Map the non-zero values of a sparse matrix <code>A</code> with the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/utils.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.readasc" href="#ConScape.readasc"><code>ConScape.readasc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readasc(::Union{String,IO}; nodata_value=0.0)::Tuple{Matrix{Float64}, Dict{String,Int}}</code></pre><p>Read asc file of raster data and return tuple of a raster matrix and a dictionary containing the metadata information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/io.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConScape.writeasc" href="#ConScape.writeasc"><code>ConScape.writeasc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writeasc(fn::String, m::Matrix{&lt;:Real}; kwargs...)</code></pre><p>Write the raster matrix <code>m</code> to a file named <code>fn</code>. It&#39;s possible to pass metadata arguments <code>xllcorner</code>, <code>yllcorner</code>, <code>cellsize</code>, <code>nodata_value</code> as keywords or as a single dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ConScape/ConScape.jl/blob/c6d8e3d82a26f181c4f734f5d34e6dcd1b3dc99b/src/io.jl#L55-L59">source</a></section></article><p>This package is derived from the Python package <a href="https://bitbucket.org/rdevooght/reindeers.git">reindeers</a>.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 4 July 2024 14:07">Thursday 4 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
